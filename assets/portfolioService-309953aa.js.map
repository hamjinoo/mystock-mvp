{"version":3,"file":"portfolioService-309953aa.js","sources":["../../src/services/portfolioService.ts"],"sourcesContent":["import { NewPortfolio, NewPosition, Portfolio, Position } from \"../types\";\r\nimport { db } from \"./db\";\r\n\r\nexport class PortfolioService {\r\n  static async getAll(): Promise<Portfolio[]> {\r\n    const portfolios = await db.portfolios.toArray();\r\n    console.log(\r\n      \"DB의 모든 포트폴리오 데이터 (상세):\",\r\n      portfolios.map((p) => ({\r\n        id: p.id,\r\n        name: p.name,\r\n        accountId: p.accountId,\r\n        config: p.config,\r\n      }))\r\n    );\r\n    return portfolios;\r\n  }\r\n\r\n  static async getById(id: number): Promise<Portfolio | undefined> {\r\n    return await db.portfolios.get(id);\r\n  }\r\n\r\n  static async create(data: NewPortfolio): Promise<Portfolio> {\r\n    // 기본 설정 추가\r\n    const portfolioWithDefaults = {\r\n      ...data,\r\n      config: data.config || {\r\n        totalCapital: 0,\r\n        targetAllocation: 0,\r\n        categoryAllocations: {\r\n          LONG_TERM: {\r\n            targetPercentage: 50,\r\n            maxStockPercentage: 10,\r\n            maxEntries: 3,\r\n          },\r\n          MID_TERM: {\r\n            targetPercentage: 30,\r\n            maxStockPercentage: 7.5,\r\n            maxEntries: 2,\r\n          },\r\n          SHORT_TERM: {\r\n            targetPercentage: 5,\r\n            maxStockPercentage: 5,\r\n            maxEntries: 1,\r\n          },\r\n          UNCATEGORIZED: {\r\n            targetPercentage: 15,\r\n            maxStockPercentage: 100,\r\n            maxEntries: 1,\r\n          },\r\n        },\r\n      },\r\n    };\r\n\r\n    const id = await db.addPortfolio(portfolioWithDefaults);\r\n    const portfolio = await this.getById(id);\r\n    if (!portfolio) throw new Error(\"포트폴리오 생성에 실패했습니다.\");\r\n    return portfolio;\r\n  }\r\n\r\n  static async update(id: number, data: Partial<Portfolio>): Promise<void> {\r\n    await db.portfolios.update(id, data);\r\n  }\r\n\r\n  static async delete(id: number): Promise<void> {\r\n    await db.transaction(\r\n      \"rw\",\r\n      [db.portfolios, db.positions, db.todos],\r\n      async () => {\r\n        await db.positions.where(\"portfolioId\").equals(id).delete();\r\n        await db.todos.where(\"portfolioId\").equals(id).delete();\r\n        await db.portfolios.delete(id);\r\n      }\r\n    );\r\n  }\r\n\r\n  static async getWithPositions(\r\n    id: number\r\n  ): Promise<Portfolio & { positions: Position[] }> {\r\n    const portfolio = await this.getById(id);\r\n    if (!portfolio) throw new Error(\"포트폴리오를 찾을 수 없습니다.\");\r\n\r\n    const positions = await db.positions\r\n      .where(\"portfolioId\")\r\n      .equals(id)\r\n      .toArray();\r\n\r\n    return {\r\n      ...portfolio,\r\n      positions,\r\n    };\r\n  }\r\n\r\n  static async getConsolidatedPositions(portfolioIds: number[]) {\r\n    const positions = await db.positions\r\n      .where(\"portfolioId\")\r\n      .anyOf(portfolioIds)\r\n      .toArray();\r\n\r\n    const consolidatedMap = new Map<string, any>();\r\n\r\n    positions.forEach((position) => {\r\n      const key = position.symbol;\r\n      if (!consolidatedMap.has(key)) {\r\n        consolidatedMap.set(key, {\r\n          symbol: position.symbol,\r\n          name: position.name,\r\n          totalQuantity: 0,\r\n          weightedAvgPrice: 0,\r\n          currentPrice: position.currentPrice,\r\n          positions: [],\r\n        });\r\n      }\r\n\r\n      const consolidated = consolidatedMap.get(key);\r\n      const prevTotal =\r\n        consolidated.totalQuantity * consolidated.weightedAvgPrice;\r\n      const newQuantity = consolidated.totalQuantity + position.quantity;\r\n\r\n      consolidated.totalQuantity = newQuantity;\r\n      consolidated.weightedAvgPrice =\r\n        (prevTotal + position.quantity * position.avgPrice) / newQuantity;\r\n      consolidated.positions.push(position);\r\n    });\r\n\r\n    return Array.from(consolidatedMap.values());\r\n  }\r\n\r\n  static async createPosition(data: NewPosition): Promise<Position> {\r\n    const id = await db.positions.add(data as any);\r\n    const position = await db.positions.get(id);\r\n    if (!position) throw new Error(\"포지션 생성에 실패했습니다.\");\r\n    return position;\r\n  }\r\n\r\n  static async updatePosition(\r\n    positionId: number,\r\n    data: Partial<Position>\r\n  ): Promise<void> {\r\n    const position = await db.positions.get(positionId);\r\n    if (!position) {\r\n      throw new Error(\"포지션을 찾을 수 없습니다.\");\r\n    }\r\n\r\n    const validatedData = {\r\n      ...position,\r\n      ...data,\r\n      symbol: data.symbol?.trim().toUpperCase() || position.symbol,\r\n      name: data.name || data.symbol?.trim().toUpperCase() || position.name,\r\n      strategyCategory: data.strategyCategory || position.strategyCategory,\r\n    };\r\n\r\n    await db.positions.update(positionId, validatedData);\r\n  }\r\n\r\n  static async deletePosition(positionId: number): Promise<void> {\r\n    await db.positions.delete(positionId);\r\n  }\r\n\r\n  static async updatePositionOrder(\r\n    id: number,\r\n    positions: Position[]\r\n  ): Promise<void> {\r\n    await db.transaction(\"rw\", [db.positions], async () => {\r\n      await Promise.all(\r\n        positions.map((position, index) =>\r\n          db.positions.update(position.id, { order: index })\r\n        )\r\n      );\r\n    });\r\n  }\r\n\r\n  static async getPortfolioSummary(id: number): Promise<{\r\n    totalValue: number;\r\n    totalCost: number;\r\n    returnRate: number;\r\n    positions: Position[];\r\n  }> {\r\n    const portfolio = await this.getById(id);\r\n    if (!portfolio) throw new Error(\"포트폴리오를 찾을 수 없습니다.\");\r\n\r\n    const positions = await db.positions\r\n      .where(\"portfolioId\")\r\n      .equals(id)\r\n      .toArray();\r\n\r\n    const totalValue = positions.reduce(\r\n      (sum, pos) => sum + pos.quantity * pos.currentPrice,\r\n      0\r\n    );\r\n\r\n    const totalCost = positions.reduce(\r\n      (sum, pos) => sum + pos.quantity * pos.avgPrice,\r\n      0\r\n    );\r\n\r\n    const returnRate =\r\n      totalCost > 0 ? ((totalValue - totalCost) / totalCost) * 100 : 0;\r\n\r\n    return {\r\n      totalValue,\r\n      totalCost,\r\n      returnRate,\r\n      positions,\r\n    };\r\n  }\r\n\r\n  static async getPositionById(\r\n    positionId: number\r\n  ): Promise<Position | undefined> {\r\n    return await db.positions.get(positionId);\r\n  }\r\n\r\n  static async fixPortfolioData(): Promise<void> {\r\n    const portfolios = await db.portfolios.toArray();\r\n\r\n    // accountId가 없는 포트폴리오 찾기\r\n    const invalidPortfolios = portfolios.filter((p) => !p.accountId);\r\n\r\n    if (invalidPortfolios.length > 0) {\r\n      console.log(\"accountId가 없는 포트폴리오:\", invalidPortfolios);\r\n\r\n      // 계좌 목록 가져오기\r\n      const accounts = await db.accounts.toArray();\r\n      if (accounts.length === 0) {\r\n        console.error(\"사용 가능한 계좌가 없습니다.\");\r\n        return;\r\n      }\r\n\r\n      // 첫 번째 계좌의 ID를 사용하여 포트폴리오 업데이트\r\n      const defaultAccountId = accounts[0].id;\r\n\r\n      await db.transaction(\"rw\", [db.portfolios], async () => {\r\n        for (const portfolio of invalidPortfolios) {\r\n          await db.portfolios.update(portfolio.id, {\r\n            accountId: defaultAccountId,\r\n          });\r\n        }\r\n      });\r\n\r\n      console.log(\"포트폴리오 데이터가 수정되었습니다.\");\r\n    } else {\r\n      console.log(\"모든 포트폴리오가 유효합니다.\");\r\n    }\r\n  }\r\n}\r\n"],"names":["PortfolioService","getAll","db","portfolios","toArray","getById","id","get","create","data","portfolioWithDefaults","config","totalCapital","targetAllocation","categoryAllocations","LONG_TERM","targetPercentage","maxStockPercentage","maxEntries","MID_TERM","SHORT_TERM","UNCATEGORIZED","addPortfolio","portfolio","this","Error","update","transaction","positions","todos","async","where","equals","delete","getWithPositions","getConsolidatedPositions","portfolioIds","anyOf","consolidatedMap","Map","forEach","position","key","symbol","has","set","name","totalQuantity","weightedAvgPrice","currentPrice","consolidated","prevTotal","newQuantity","quantity","avgPrice","push","Array","from","values","createPosition","add","updatePosition","positionId","validatedData","trim","toUpperCase","strategyCategory","deletePosition","updatePositionOrder","Promise","all","map","index","order","getPortfolioSummary","totalValue","reduce","sum","pos","totalCost","returnRate","getPositionById","fixPortfolioData","invalidPortfolios","filter","p","accountId","length","accounts","defaultAccountId"],"mappings":"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"}