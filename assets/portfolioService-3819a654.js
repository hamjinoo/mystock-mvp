import{d as t}from"./index-65335e1b.js";class a{static async getAll(){return await t.portfolios.toArray()}static async getById(a){return await t.portfolios.get(a)}static async create(a){const o={...a,config:a.config||{totalCapital:0,targetAllocation:0,categoryAllocations:{LONG_TERM:{targetPercentage:50,maxStockPercentage:10,maxEntries:3},MID_TERM:{targetPercentage:30,maxStockPercentage:7.5,maxEntries:2},SHORT_TERM:{targetPercentage:5,maxStockPercentage:5,maxEntries:1},UNCATEGORIZED:{targetPercentage:15,maxStockPercentage:100,maxEntries:1}}}},i=await t.addPortfolio(o),e=await this.getById(i);if(!e)throw new Error("포트폴리오 생성에 실패했습니다.");return e}static async update(a,o){await t.portfolios.update(a,o)}static async delete(a){await t.transaction("rw",[t.portfolios,t.positions,t.todos],(async()=>{await t.positions.where("portfolioId").equals(a).delete(),await t.todos.where("portfolioId").equals(a).delete(),await t.portfolios.delete(a)}))}static async getWithPositions(a){const o=await this.getById(a);if(!o)throw new Error("포트폴리오를 찾을 수 없습니다.");const i=await t.positions.where("portfolioId").equals(a).toArray();return{...o,positions:i}}static async getConsolidatedPositions(a){const o=await t.positions.where("portfolioId").anyOf(a).toArray(),i=new Map;return o.forEach((t=>{const a=t.symbol;i.has(a)||i.set(a,{symbol:t.symbol,name:t.name,totalQuantity:0,weightedAvgPrice:0,currentPrice:t.currentPrice,positions:[]});const o=i.get(a),e=o.totalQuantity*o.weightedAvgPrice,r=o.totalQuantity+t.quantity;o.totalQuantity=r,o.weightedAvgPrice=(e+t.quantity*t.avgPrice)/r,o.positions.push(t)})),Array.from(i.values())}static async createPosition(a){const o=await t.positions.add(a),i=await t.positions.get(o);if(!i)throw new Error("포지션 생성에 실패했습니다.");return i}static async updatePosition(a,o){const i=await t.positions.get(a);if(!i)throw new Error("포지션을 찾을 수 없습니다.");const e={...i,...o,symbol:o.symbol?.trim().toUpperCase()||i.symbol,name:o.name||o.symbol?.trim().toUpperCase()||i.name,strategyCategory:o.strategyCategory||i.strategyCategory};await t.positions.update(a,e)}static async deletePosition(a){await t.positions.delete(a)}static async updatePositionOrder(a,o){await t.transaction("rw",[t.positions],(async()=>{await Promise.all(o.map(((a,o)=>t.positions.update(a.id,{order:o}))))}))}static async getPortfolioSummary(a){if(!(await this.getById(a)))throw new Error("포트폴리오를 찾을 수 없습니다.");const o=await t.positions.where("portfolioId").equals(a).toArray(),i=o.reduce(((t,a)=>t+a.quantity*a.currentPrice),0),e=o.reduce(((t,a)=>t+a.quantity*a.avgPrice),0);return{totalValue:i,totalCost:e,returnRate:e>0?(i-e)/e*100:0,positions:o}}static async getPositionById(a){return await t.positions.get(a)}static async fixPortfolioData(){const a=(await t.portfolios.toArray()).filter((t=>!t.accountId));if(a.length>0){const o=await t.accounts.toArray();if(0===o.length)return;const i=o[0].id;await t.transaction("rw",[t.portfolios],(async()=>{for(const o of a)await t.portfolios.update(o.id,{accountId:i})}))}}}export{a as P};
//# sourceMappingURL=portfolioService-3819a654.js.map
